#!/usr/bin/env ruby
require 'optparse'
require 'cfn_manage/version'
require 'cfn_manage/cf_common'
require 'cfn_manage/cf_start_stop_environment'
require 'cfn_manage/logging'
#require 'logger'

# exit with usage information
def print_usage_exit(code)
  STDERR.puts(File.open("#{File.expand_path(File.dirname(__FILE__))}/usage.txt").read)
  exit code
end

# global options
$options = {}
$options['SOURCE_BUCKET'] = ENV['SOURCE_BUCKET']
$options['AWS_ASSUME_ROLE'] = ENV['AWS_ASSUME_ROLE']

run_configuration = {
  dry_run: false,
  skip_wait: false,
  continue_on_error: false,
  asg_suspend_termination: false,
  ignore_missing_ecs_config: false,
  collect_method: 'Query',
  save_to_filename: nil,
  load_from_filename: nil,
  config_file: nil
}

config_file = nil

# global logger
#$log = Logger.new(STDOUT)

# always flush output
STDOUT.sync = true

# parse command line options
OptionParser.new do |opts|

  Version = CfnManage::VERSION

  opts.banner = 'Usage: cfn_manage [command] [options]'

  opts.on('--source-bucket [BUCKET]') do |bucket|
    $options['SOURCE_BUCKET'] = bucket
    ENV['SOURCE_BUCKET'] = bucket
  end

  opts.on('--aws-role [ROLE]') do |role|
    ENV['AWS_ASSUME_ROLE'] = role
  end

  opts.on('--stack-name [STACK_NAME]') do |stack|
    $options['STACK_NAME'] = stack
  end

  opts.on('--asg-name [ASG]') do |asg|
    $options['ASG'] = asg
  end

  opts.on('--rds-instance-id [RDS_INSTANCE_ID]') do |rds|
    $options['RDS_INSTANCE_ID'] = rds
  end

  opts.on('--aurora-cluster-id [AURORA_CLUSTER_ID]') do |cluster|
    $options['AURORA_CLUSTER_ID'] = cluster
  end

  opts.on('--docdb-cluster-id [DOCDB_CLUSTER_ID]') do |cluster|
    $options['DOCDB_CLUSTER_ID'] = cluster
  end

  opts.on('--transfer-server-id [TRANSFER_SERVER_ID]') do |server|
    $options['TRANSFER_SERVER_ID'] = server
  end

  opts.on('--ec2-instance-id [EC2_INSTANCE_ID]') do |ec2|
    $options['EC2_INSTANCE_ID'] = ec2
  end

  opts.on('--spot-fleet-id [SPOT_FLEET]') do |spot|
    $options['SPOT_FLEET'] = spot
  end

  opts.on('--ecs-cluster [ECS_CLUSTER]') do |ecs|
    $options['ECS_CLUSTER'] = ecs
  end

  opts.on('--alarm [ALARM]') do |alarm|
    $options['ALARM'] = alarm
  end

  opts.on('-r [AWS_REGION]', '--region [AWS_REGION]') do |region|
    ENV['AWS_REGION'] = region
  end

  opts.on('-p [AWS_PROFILE]', '--profile [AWS_PROFILE]') do |profile|
    ENV['CFN_AWS_PROFILE'] = profile
  end

  opts.on('--dry-run') do
    run_configuration[:dry_run] = true
  end

  opts.on('--continue-on-error') do
    run_configuration[:continue_on_error] = true
  end

  opts.on('--skip-wait') do
    run_configuration[:skip_wait] = true
  end

  opts.on('--ignore-missing-ecs-config') do
    run_configuration[:ignore_missing_ecs_config] = true
  end

  opts.on('--asg-suspend-termination') do
    run_configuration[:asg_suspend_termination] = true
  end

  opts.on('--from-file [FILE]') do |filename|
    if !File.file?(filename)
      STDERR.puts("ERROR - the file '#{filename}' does not exist.")
      exit(1)
    end

    run_configuration[:collect_method] = 'File'
    run_configuration[:load_from_filename] = filename
  end

  opts.on('--to-file [FILE]') do |filename|
    run_configuration[:save_to_filename] = filename
  end

  opts.on('--config [FILE]') do |filename|
    if !File.file?(filename)
      STDERR.puts("ERROR - the file '#{filename}' does not exist.")
      exit(1)
    end
    run_configuration[:config_file] = filename
  end

  opts.on('--log-level [LEVEL]') do |level|
    levels = %w[debug info warn error fatal].freeze
    if !levels.include?(level)
      STDERR.puts("ERROR - the argument to --log-level must be one of: #{levels.join(' | ')}")
      exit(1)
    end
    $log.level = levels.index(level)
  end

end.parse!

command = ARGV[0]

if command.nil?
  print_usage_exit(-1)
end

# TODO: below
runner = CfnManage::CloudFormation::EnvironmentRunStop.new(run_configuration)

case command
  when 'help'
    print_usage_exit(0)
  # asg commands
  when 'stop-asg'
    runner.stop_resource($options['ASG'],'AWS::AutoScaling::AutoScalingGroup')
  when 'start-asg'
    runner.start_resource($options['ASG'],'AWS::AutoScaling::AutoScalingGroup')

  # rds commands
  when 'stop-rds'
    runner.stop_resource($options['RDS_INSTANCE_ID'],'AWS::RDS::DBInstance')
  when 'start-rds'
    runner.start_resource($options['RDS_INSTANCE_ID'],'AWS::RDS::DBInstance')

  # aurora cluster commands
  when 'stop-aurora-cluster'
    runner.stop_resource($options['AURORA_CLUSTER_ID'],'AWS::RDS::DBCluster')
  when 'start-aurora-cluster'
    runner.start_resource($options['AURORA_CLUSTER_ID'],'AWS::RDS::DBCluster')

  # docdb cluster commands
  when 'stop-docdb-cluster'
    runner.stop_resource($options['DOCDB_CLUSTER_ID'],'AWS::DocDB::DBCluster')
  when 'start-docdb-cluster'
    runner.start_resource($options['DOCDB_CLUSTER_ID'],'AWS::DocDB::DBCluster')

  # docdb cluster commands
when 'stop-transfer-server'
  runner.stop_resource($options['TRANSFER_SERVER_ID'],'AWS::Transfer::Server')
when 'start-transfer-server'
  runner.start_resource($options['TRANSFER_SERVER_ID'],'AWS::Transfer::Server')

  # ec2 instance
  when 'stop-ec2'
    runner.stop_resource($options['EC2_INSTANCE_ID'],'AWS::EC2::Instance')
  when 'start-ec2'
    runner.start_resource($options['EC2_INSTANCE_ID'],'AWS::EC2::Instance')

  # spot fleet
  when 'stop-spot-fleet'
    runner.stop_resource($options['SPOT_FLEET'],'AWS::EC2::SpotFleet')
  when 'start-spot-fleet'
    runner.start_resource($options['SPOT_FLEET'],'AWS::EC2::SpotFleet')

    # spot fleet
  when 'stop-ecs-cluster'
    runner.stop_resource($options['ECS_CLUSTER'],'AWS::ECS::Cluster')
  when 'start-ecs-cluster'
    runner.start_resource($options['ECS_CLUSTER'],'AWS::ECS::Cluster')


  # cloudwatch alarm
  when 'disable-alarm'
    runner.stop_resource($options['ALARM'],'AWS::CloudWatch::Alarm')
  when 'enable-alarm'
    runner.start_resource($options['ALARM'],'AWS::CloudWatch::Alarm')

  # stack commands
  when 'stop-environment'
    runner.stop_environment($options['STACK_NAME'])
  when 'start-environment'
    runner.start_environment($options['STACK_NAME'])
end
